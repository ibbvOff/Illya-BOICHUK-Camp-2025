import numpy as np

def simulate_flips():
    """
    Маємо 5 монет з різними ймовірностями випадіння орла (p_heads).
    Спостерігаємо послідовність результатів підкидання і оновлюємо ймовірність того,
    яку саме монету ми підкидаємо, використовуючи теорему Байєса.
    """
    # Ймовірності випадіння орла для кожної з 5 монет
    p_heads = np.array([0.8, 0.9, 0.1, 0.2, 0.3])
    
    # Початкові ймовірності того, що ми використовуємо конкретну монету
    # Спочатку вважаємо, що всі монети рівноймовірні (по 1/5 = 0.2)
    p_coins = np.ones(5) / 5

    # Список результатів підкидань: True = орел (H), False = решка (T)
    flips = [True, False, True, True, True, False, False, True, True]

    # Обчислення початкової ймовірності випадіння орла на наступному підкиданні
    # з урахуванням ймовірностей для кожної монети
    start_prob = np.sum(p_coins * p_heads)
    print(f"Початкова ймовірність 'H': {start_prob:.2f}")
    
    # Список для зберігання оновлених ймовірностей випадіння орла після кожного підкидання
    next_probs = []

    # Обробка кожного результату підкидання
    for i, is_heads in enumerate(flips):
        # Обчислення ймовірності спостереження поточного результату для кожної монети
        # Якщо випав орел (is_heads=True), використовуємо p_heads
        # Якщо випала решка (is_heads=False), використовуємо 1-p_heads
        chance = p_heads if is_heads else 1 - p_heads
        
        # Застосування теореми Байєса для оновлення ймовірностей монет:
        # P(монета | результат) = P(результат | монета) * P(монета) / P(результат)
        # Тут:
        # - p_coins * chance: добуток апріорних ймовірностей і правдоподібностей
        # - np.sum(p_coins * chance): нормалізуючий фактор (загальна ймовірність спостереження)
        p_coins = p_coins * chance / np.sum(p_coins * chance)

        # Обчислення нової ймовірності випадіння орла на наступному підкиданні
        next_prob = np.sum(p_coins * p_heads)
        next_probs.append(round(next_prob, 2))

        # Виведення результатів для поточного підкидання
        flip_res = "H" if is_heads else "T"
        print(f"Після {i+1}-го підкидання ({flip_res}): ймовірність 'H' = {next_prob:.2f}")
        print(f"  Ймовірності монет: {p_coins.round(4)}")

    return next_probs

# Виклик функції моделювання і збереження результатів
probs = simulate_flips()

# Виведення відповіді з початковою ймовірністю 0.69 та обчисленими ймовірностями
print("\nВідповідь:")
print(f"[0.69, {', '.join(map(str, probs))}]")