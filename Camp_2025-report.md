# Illya-BOICHUK-test_tasks_Camp_2025

# Звіт по виконанню завдання Data Science Camp 2025

## Task 1

### Опис роботи
В даному коді було використано такі бібліотеки `import numpy as np` для роботи з масивами та математичними функціями, `import matplotlib.pyplot as plt` для візуалізації даних

### 1. Функція пошуку озера `find_lake`
- Функція `find_lake` використовує вкладені цикли для перебору всіх можливих комбінацій лівої та правої "стінки" потенційного озера,перебирає всі можливі позиції для лівої стінки (`l`) від 0 до `n-3`, для кожної лівої стінки перебирає всі можливі позиції для правої стінки (`r`) починаючи з `l+2` до `n-1`. Вимога `l+2` гарантує, що між стінками є хоча б одна точка для "озера"

Для кожної пари стінок (l, r) виконуються такі перевірки:
1. Рівень води в озері визначається висотою нижчої з двох стінок: `wall_h = min(h[l], h[r])`
2. `mid_h = h[l+1:r]` — всі висоти між лівою та правою стінкою
3. `if max(mid_h) < wall_h` — перевіряє, чи всі проміжні точки мають висоту меншу за нижчу стінку
      - Якщо хоча б одна проміжна точка вища або рівна `wall_h`, це не озеро
4. Пошук найнижчої точки озера: 
      - `min_h = min(mid_h)` — висота найнижчої точки
      - `min_idx = l + 1 + np.argmin(mid_h)` — індекс найнижчої точки (зсунутий на `l+1`, оскільки `argmin` повертає індекс відносно підмасиву `mid_h`)
5. `depth = wall_h - min_h` — різниця між рівнем води та найнижчою точкою озера
6. Якщо поточне озеро глибше за попереднє найглибше, зберігаємо його параметри

### 2. Візуалізація результатів `plot_h`
Функція `plot_h` створює графічне представлення рельєфу та знайденого озера:

1. `plt.figure(figsize=(12, 6))` — створює полотно для графіка заданого розміру
2. Синя лінія з маркерами представляє весь рельєф
3. `if lake`, виконується додаткова візуалізація:
      - Ділянка рельєфу, що представляє озеро (від лівої до правої стінки), виділяється червоним кольором
      - Розраховується рівень води: `wall_h = min(h[l], h[r])`
      - Малюється зелена пунктирна вертикальна лінія від дна озера до рівня води, що показує глибину
4. Додаються підписи осей, заголовок, сітка та легенда

Цей алгоритм має часову складність O(n³), де n — кількість точок висоти, оскільки включає вкладені цикли та додаткові операції пошуку мінімуму/максимуму в підмасивах.

## Task 2

### Опис роботи
В даному коді було використано такі бібліотеки `import numpy as np` для роботи з масивами та математичними функціями, `import matplotlib.pyplot as plt` для візуалізації даних.

### Початкові налаштування і генерація даних
**Спочатку код встановлює два ключові параметри:**
   - `SIZE = 20` визначає розмір квадратної сітки 20×20 клітин
   - `STEPS = 20` визначає кількість поколінь, які будуть симульовані

**Створюється випадкова початкова сітка:**
   - 70% клітин будуть мертвими (значення 0)
   - 30% клітин будуть живими (значення 1)
   - Це робиться за допомогою `np.random.choice`

### Головний алгоритм оновлення сітки
- Функція `update` є серцем програми і визначає правила еволюції:
Спочатку сітка розширюється по краях нулями (`np.pad`), щоб спростити обчислення кількості сусідів для крайніх клітин. Створюється порожній масив `neighbors` для підрахунку кількості живих сусідів кожної клітини. Два вкладені цикли перебирають всі можливі відносні позиції сусідів (3×3 область), крім центральної клітини.Для кожної клітини підраховується кількість живих сусідів

**Застосовуються правила Гри життя:**
   - Мертва клітина з рівно 3 живими сусідами оживає
   - Жива клітина з менше ніж 2 або більше ніж 3 живими сусідами помирає
   - В інших випадках клітини зберігають свій стан

**Код зберігає історію:**
   - Список `grids` зберігає стан сітки на кожному кроці
   - Список `alive_cells` відстежує кількість живих клітин на кожному кроці

**Основний цикл симуляції виконує 20 кроків еволюції:**
   - На кожному кроці викликається функція `update` для обчислення нового стану
   - Новий стан і кількість живих клітин додаються до відповідних списків

### Візуалізація результатів

**Функція `show_grid` створює і зберігає зображення станів сітки:**
   - Живі клітини відображаються зеленим кольором
   - Відображення відбувається без координатної сітки для наочності

**В кінці виводиться статистика:**
   - Початкова кількість живих клітин
   - Кінцева кількість живих клітин після 20 поколінь
   - Зміна кількості живих клітин

## Task 3
### Опис роботи:
1. **Початкові дані:**
- Маємо 5 різних монет з ймовірностями випадіння орла: 0.8, 0.9, 0.1, 0.2, 0.3. Спочатку ми не знаємо, яку саме монету підкидаємо, тому вважаємо, що кожна монета обрана з ймовірністю 1/5.

2. **Обчислення початкової ймовірності:**
- Ймовірність отримати орла на наступному підкиданні обчислюється як зважена сума ймовірностей орла для кожної монети. Початкова ймовірність = 0.8×0.2 + 0.9×0.2 + 0.1×0.2 + 0.2×0.2 + 0.3×0.2 = 0.46.

3. **Послідовне оновлення ймовірностей:**
- Для кожного результату підкидання (орел чи решка) оновлюємо наше уявлення про те, яку монету ми використовуємо.cЦе робиться за допомогою теореми Байєса:
     ```
     P(монета_i | результат) = P(результат | монета_i) × P(монета_i) / P(результат)
     ```
Де P(результат) = ∑[P(результат | монета_j) × P(монета_j)] для всіх монет j

4. **Ітеративний процес:**
- Після кожного підкидання обчислюємо нові ймовірності для кожної монети. На основі цих оновлених ймовірностей розраховуємо очікувану ймовірність орла на наступному підкиданні. Результати округлюються до 2 знаків після коми.

5. **Результати:**
- Код відстежує, як змінюється наше уявлення про ймовірність появи орла з кожним новим підкиданням. Також виводиться, як змінюються ймовірності того, що ми використовуємо кожну з п'яти монет.

Цей алгоритм демонструє, як ми можемо оновлювати наші переконання на основі нових доказів, використовуючи байєсівський підхід. З кожним новим підкиданням ми отримуємо більше інформації про те, яка монета найімовірніше використовується, і відповідно уточнюємо нашу оцінку ймовірності випадіння орла на наступному підкиданні.